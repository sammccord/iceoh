"use strict";var z=Object.defineProperty;var S=(u,r,e)=>r in u?z(u,r,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[r]=e;var o=(u,r,e)=>(S(u,typeof r!="symbol"?r+"":r,e),e);Object.defineProperties(exports,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}});const w=require("./Tilemap.umd.js"),l=require("./utils.umd.js");class C extends w.Tilemap{constructor({angle:e=l.CLASSIC,clamp:s=!0,...t}={angle:l.CLASSIC,clamp:!0}){super({...t});o(this,"angle");o(this,"angleCos");o(this,"angleSin");o(this,"clamp");o(this,"baseOrigin");o(this,"baseSurfaceHeight");o(this,"baseSurfaceHalfHeight");o(this,"tileDimensions",new Map);this.angle=e,this.angleCos=Math.cos(this.angle),this.angleSin=Math.sin(this.angle),this.clamp=s,this.baseOrigin={x:this.baseTileDimensions.width*this.baseTileOrigin.x,y:this.baseTileDimensions.height*this.baseTileOrigin.y},this.baseSurfaceHeight=this.baseTileDimensions.height-(this.baseTileDimensions.depth||1),this.baseSurfaceHalfHeight=this.baseSurfaceHeight/2}get baseDepth(){return this.baseTileDimensions.depth||1}add(e,s,t=this.baseTileDimensions,i=this.baseTileOrigin){const h=this.toWorldPoint(s,t,i);if(t!==this.baseTileDimensions){let y=(t.depth||this.baseDepth)/this.baseDepth;for(let n=y,a=s.z||0;n>0;n--,a++)n>1?l.set(this.tileDimensions,[a,s.x,s.y],{...t,origin:i,depth:this.baseDepth,z:a,x:h.x,y:h.y,value:e}):l.set(this.tileDimensions,[a,s.x,s.y],{...t,origin:i,depth:this.baseDepth*n,z:a,x:h.x,y:h.y,value:e}),l.set(this.map,[a,s.x,s.y],s)}else l.set(this.tileDimensions,[s.z||0,s.x,s.y],{...t,origin:i,z:s.z||0,x:h.x,y:h.y,value:e}),l.set(this.map,[s.z||0,s.x,s.y],s);return this.recalculateBounds(s),h}remove(e){const s=this.get(e);if(!!s){for(const[t,i]of this.map)try{l.get(i,[e.x,e.y])===s&&(l.remove(this.tileDimensions,[t,e.x,e.y]),l.remove(this.map,[t,e.x,e.y]))}catch{}return this.recalculateBounds(e),s}}worldToTile(e,s=this.baseTileDimensions,t=this.baseTileOrigin){const i=this._unproject(e),h={x:s.width*t.x,y:s.width*t.y};return i.x=Math.floor((i.x+h.x)/h.x),i.y=Math.floor((i.y+h.y)/h.y),i.z=i.z||0,i}toWorldPoint(e,s=this.baseTileDimensions,t=this.baseTileOrigin){return this._project(this._getAbsolutePosition(e),s,t,l.sum(this.getDimensionsColumn(e).map(i=>(i==null?void 0:i.depth)||this.baseTileDimensions.depth).slice(1,e.z||0)))}getDimensionsColumn(e){return this.getColumn(e,this.tileDimensions)}castRay(e,s){const t=this.worldToTile(e);for(let i=this.bounds.z.max;i>=this.bounds.z.min;i--){const h=t.x+i,y=t.y+i;for(let n of this.getDimensionsColumn({x:h,y}).reverse()){if(!n)continue;const{x:a,y:m,value:c,origin:g,width:b,height:f,tile:x}=n;if(e.x>=a-b*g.x&&e.x<=a+b*g.x&&e.y>=m-f*g.y&&e.y<=m+f*g.y)if(s){if(s(c,x))return c}else return c}}}collisionMap(e,s){const t=new Map,i=this.worldToTile(e);for(let h=this.bounds.z.min;h<=this.bounds.z.max;h++){let y=!1;const n=i.x+h,a=i.y+h;for(let m of this.getDimensionsColumn({x:n,y:a})){if(!m)continue;const{x:c,y:g,value:b,z:f,origin:x,width:T,height:D,tile:d}=m;if(e.x>=c-T*x.x&&e.x<=c+T*x.x&&e.y>=g-D*x.y&&e.y<=g+D*x.y){if(s&&!s(b,d))continue;y=!0,l.set(t,[f||0,n,a],b)}else if(y)break}}return t}_project(e,s=this.baseTileDimensions,t=this.baseTileOrigin,i=0){const{width:h,height:y}=this.getScreenDimensions(),n={x:(e.x-e.y)*this.angleCos+h*this.worldOrigin.x,y:(e.x+e.y)*this.angleSin+y*this.worldOrigin.y,z:(e.x+e.y)*((e.z||0)+1||1)};return s!==this.baseTileDimensions?(n.y-=this.baseSurfaceHalfHeight+0-this.baseTileOrigin.y,n.y+=s.height*t.y-(s.height-(s.height-(s.depth||0))/2),n.y-=i):n.y-=this.baseDepth*(e.z||0),this.clamp&&(n.x=~~(n.x+(n.x>0?.5:-.5)),n.y=~~(n.y+(n.y>0?.5:-.5))),n}_unproject(e,s={x:0,y:0,z:0}){const t=this.getScreenDimensions(),i=e.x-t.width*this.worldOrigin.x,h=e.y-t.height*this.worldOrigin.y;return s.x=i/(2*this.angleCos)+h/(2*this.angleSin),s.y=-(i/(2*this.angleCos))+h/(2*this.angleSin),s.z=e.z||0,s}_getAbsolutePosition(e,s=this.baseTileDimensions,t=this.baseTileOrigin){return{x:s.width*t.x*e.x,y:s.height*t.y*e.y,z:e.z||0}}}exports.IsoTilemap=C;
