{"version":3,"file":"index.module.js","sources":["../src/utils.ts","../src/Tilemap.ts","../src/IsoTilemap.ts"],"sourcesContent":["import { IPoint, IPoint3 } from \"./interfaces\"\n\n/**\n * Classic 2:1 projection angle found in most isometric games\n * \n * @type {number}\n */\nexport const CLASSIC = Math.atan(0.5);\n/**\n * Isometric projection\n *\n * @type {number}\n */\nexport const ISOMETRIC = Math.PI / 6;\n/**\n * Military projection\n * \n * @type {number}\n */\nexport const MILITARY = Math.PI / 4;\n\n/**\n * Point specifying top left placement factor\n * \n * @type {IPoint}\n */\nexport const TOP_LEFT: IPoint = { x: 0, y: 0 }\n\n/**\n * Point specifying middle placement factor\n * \n * @type {IPoint}\n */\nexport const MIDDLE: IPoint = { x: 0.5, y: 0.5 }\n\n/**\n * Point specifying a factor of 1 for both axes\n * \n * @type {IPoint}\n */\nexport const FULL: IPoint = { x: 1, y: 1 }\n\n/**\n * Enum specifying compass directions, including NONE\n * \n * @type {DIRECTION}\n */\nexport enum DIRECTION {\n  NONE = 'NONE',\n  N = 'N',\n  NE = 'NE',\n  E = 'E',\n  SE = 'SE',\n  S = 'S',\n  SW = 'SW',\n  W = 'W',\n  NW = 'NW'\n}\n\n/**\n * Deeply set a value in object at given indices using objects for new path creation\n *\n * @param {object} obj - Object to deeply set\n * @param {number[]} indices - Array of keys to set\n * @param {any} value - The value to set\n * @return {any} The value set\n *\n * @example\n *\n *    const tile = set({}, [0, 1, 2], sprite)\n */\nexport function set<T>(obj: {}, indices: number[], value: T): T {\n  var o = obj\n  while (indices.length - 1) {\n    var n = indices.shift()\n    if (!(n in o)) o[n] = {}\n    o = o[n]\n  }\n  o[indices[0]] = value\n  return o[indices[0]]\n}\n\n/**\n * Deeply get a value from an object at given indicies path.\n * If `setIfNull` is provided, new objects will be used for path creation and the value will be set.\n *\n * @param {object} obj - Object to deeply get\n * @param {number[]} indices - Array of keys to get\n * @param {any} [setIfNull] - The value to set, if any\n * @return {any} The value at given indices\n *\n * @example\n *\n *    const tile = get({}, [0, 1, 2], sprite)\n */\nexport function get<T>(obj: {}, indices: number[], setIfNull?: T): T {\n  var o = obj\n  while (indices.length) {\n    var n = indices.shift()\n    if (!(n in o)) {\n      if (setIfNull) {\n        o[n] = {}\n        if (!indices.length) o[n] = setIfNull\n      }\n      else return\n    }\n    o = o[n]\n  }\n  return o as T\n}\n\n/**\n * Gets distance between two 2D Points\n *\n * @param {IPoint} from\n * @param {IPoint} to\n * @return {number} Distance\n *\n * @example\n *\n *    const tile = getDistance({ x: 5, y: 5 }, { x: 10, y: 10 })\n */\nexport function getDistance(from: IPoint, to: IPoint): number {\n  return Math.sqrt((to.x - from.x) * (to.x - from.x) + (to.y - from.y) * (to.y - from.y));\n}\n\n/**\n * Sums an array of numbers, ignoring null values\n *\n * @param {number[]} numbers\n * @return {number} sum\n *\n * @example\n *\n *    const total = sum([ 1, 10, null, 5 ])\n */\nexport function sum(numbers: number[]): number {\n  return numbers.reduce((s, n) => !!n ? s + n : s, 0)\n}\n\nconst ZERO = 0\n/**\n * Gets compass direction between two points\n *\n * @param {IPoint} from\n * @param {IPoint} to\n * @return {DIRECTION}\n *\n * @example\n *\n *    const direction = getDirection({ x: 1, y: 1 }, { x: 1: y: 0 }) // DIRECTION.N\n */\nexport function getDirection(from: IPoint3, to: IPoint3): DIRECTION {\n  let diffX = to.x - from.x, diffY = to.y - from.y\n  if (diffX === ZERO && diffY < ZERO) return DIRECTION.N\n  if (diffX > ZERO && diffY < ZERO) return DIRECTION.NE\n  if (diffX > ZERO && diffY === ZERO) return DIRECTION.E\n  if (diffX > ZERO && diffY > ZERO) return DIRECTION.SE\n  if (diffX === ZERO && diffY > ZERO) return DIRECTION.S\n  if (diffX < ZERO && diffY > ZERO) return DIRECTION.SW\n  if (diffX < ZERO && diffY === ZERO) return DIRECTION.W\n  if (diffX < ZERO && diffY < ZERO) return DIRECTION.NW\n  return DIRECTION.NONE\n}\n","import { IPoint3, IPoint, IRectangle, IRectangle3, IBox } from './interfaces'\nimport { get, set, MIDDLE, FULL, TOP_LEFT } from './utils'\n\n/**\n * Tilemap configuration\n */\nexport interface ITilemapConfig {\n  /** The screen offset for the 0,0 coordinate, deaults to `MIDDLE` */\n  worldOrigin?: IPoint\n  /** The anchor point at which tiles are expected to be drawn to screen, defaults to `MIDDLE` */\n  baseTileOrigin?: IPoint\n  /**\n   * The base dimensions of tiles that comprise the map.\n   * In 2D Tilemaps this would ideally be squares, `{ x: 32, y: 32 }`.\n   * Isometric tilemaps expect a depth field to correctly place tiles at z > 0\n   */\n  baseTileDimensions: IRectangle3\n  /** A getter function that retuns the dimensions of the canvas */\n  getGlobalDimensions: () => IRectangle\n  /** A getter function that returns the world offset, this defaults to `() => { x: 0, y: 0 }` */\n  getWorldPosition?: () => IPoint\n  /** A getter function that returns the world scale, this defaults to `() => { x: 1, y: 1 }` */\n  getWorldScale?: () => IPoint\n}\n\nexport class Tilemap<T> {\n  protected getGlobalDimensions: () => IRectangle\n  protected getWorldPosition: () => IPoint\n  protected getWorldScale: () => IPoint\n  protected baseTileDimensions: IRectangle3\n\n  protected readonly worldOrigin: IPoint = MIDDLE\n  protected readonly baseTileOrigin: IPoint = MIDDLE\n  protected readonly tiles: T[] = []\n  protected readonly map: { [z: number]: { [x: number]: { [y: number]: T } } } = {}\n\n  /**\n  * Create a `Tilemap<T>` instance.\n  * @param {ITilemapConfig} config\n  */\n  constructor({ worldOrigin, baseTileOrigin, baseTileDimensions, getGlobalDimensions, getWorldPosition, getWorldScale }: ITilemapConfig) {\n    this.worldOrigin = worldOrigin || MIDDLE\n    this.baseTileOrigin = baseTileOrigin || MIDDLE\n    this.baseTileDimensions = baseTileDimensions\n    this.getGlobalDimensions = getGlobalDimensions\n    this.getWorldPosition = getWorldPosition || (() => TOP_LEFT)\n    this.getWorldScale = getWorldScale || (() => FULL)\n  }\n\n  /**\n  * Add tile to the tilemap at given coordinate.\n  * @param {T} tile\n  * @param {IPoint3} point - The map coordinates at which to store this tile\n  * @param {IRectangle3=} dimensions - The dimensions of the tile tile, defaults to `this.baseTileDimensions`\n  * @param {IPoint=} origin - The origin point of the tile\n  * @return {IPoint3} A point at which to place this tile in screen space\n  *\n  * @example\n  *\n  *    const position = isoTilemap.add({}, { x: 1, y: 1, z: 0 })\n  */\n  public add(sprite: T, point: IPoint3, dimensions: IRectangle3 = this.baseTileDimensions, origin = this.baseTileOrigin): IPoint3 {\n    this.tiles.push(sprite)\n    const tile = this.tiles[this.tiles.indexOf(sprite)]\n    set(this.map, [point.z, point.x, point.y], tile)\n    return this._project(this._getAbsolutePosition(point), dimensions, origin)\n  }\n\n  /**\n * Get a tile at given map coordinates\n *\n * @param {IPoint3} point - Tile to get at given coordinates. If no z is provided, it defaults to 0.\n * @return {T} The tile at given coordinates\n *\n * @example\n *\n *    const tile = tilemap.get({ x: 1, y: 1, z: 1 })\n */\n  public get(point: IPoint3): T {\n    return get(this.map, [point.z || 0, point.x, point.y])\n  }\n\n  /**\n  * Get an array of values from a map at given x,y coordinates.\n  *\n  * @param {IPoint} point - Map coordinates to get at each z-layer\n  * @param {object=} map - Object to search against, defaults to `this.map`, but will also work if called with `this.depthMap`, in which case numerical tile depths are returned.\n  * @return {T[]} Array of values at given x,y coordinates. If the map is multiple z-layers deep, but the tile x,y coordinate doesn't exist in all layers, the returned array will contain null entries.\n  *\n  * @example\n  *\n  *    const tiles = tilemap.getColumn({ x: 1, y: 1 })\n  *    const depths = tilemap.getColumn({ x: 1, y: ! }, tilemap.depthMap)\n  */\n  public getColumn<C>(point: IPoint, map?: {}): C[] {\n    return Object.entries(map || this.map).map(([_, grid]) => get(grid, [point.x, point.y]))\n  }\n\n  /**\n  * Moves a tile from given coordinate to another coordinate\n  * @param {IPoint3} from - The map coordinates of the tile to move\n  * @param {IPoint3} to - The map coordinates to move the tile to\n  * @param {IRectangle3=} dimensions - The dimensions of the tile, defaults to `this.baseTileDimensions`\n  * @param {IPoint=} origin - The origin point of the tile, defaults to `this.baseTileOrigin`\n  * @return {IPoint3} A point at which to place this tile in screen space\n  *\n  * @example\n  *\n  *    const position = tilemap.move({ x: 0, y: 0, z: 0 }, { x: 1, y: 1, z: 0 })\n  */\n  public move(from: IPoint3, to: IPoint3, dimensions: IRectangle = this.baseTileDimensions, origin = this.baseTileOrigin): IPoint3 {\n    const tile = this.remove(from)\n    if (!tile) return null\n    return this.add(tile, to, dimensions, origin)\n  }\n\n  /**\n  * Remove a tile from the given point coordinates.\n  *\n  * @param {IPoint3} point - Map coordinates to remove\n  * @return {[T]} The removed tile if found\n  *\n  * @example\n  *\n  *    const tile = tilemap.remove({ x: 1, y: 1 })\n  */\n  public remove(point: IPoint3): T {\n    const tile = this.get(point)\n    if (!tile) return null\n    delete this.map[point.z][point.x][point.y]\n    return this.tiles.splice(this.tiles.indexOf(tile), 1)[0]\n  }\n\n  /**\n  * Project a tile coordinate to screen space coordinate\n  * @param {IPoint3} point - The tile coordinates\n  * @param {IRectangle3=} dimensions - The dimensions of the tile, defaults to `this.baseTileDimensions`\n  * @param {IPoint=} origin - The origin point of the tile, defaults to `this.baseTileOrigin`\n  * @return {IPoint3} Screen space point\n  *\n  * @example\n  *\n  *    const position = tilemap.toPoint({ x: 1, y: 1, z: 0 })\n  */\n  public toPoint(point: IPoint3, dimensions = this.baseTileDimensions, origin = this.baseTileOrigin): IPoint3 {\n    const scale = this.getWorldScale()\n    const worldPosition = this.getWorldPosition()\n    const p = this._project(this._getAbsolutePosition(point, dimensions, origin))\n    p.x += p.x * (scale.x - 1) + worldPosition.x\n    p.y += p.y * (scale.y - 1) + worldPosition.y\n    return p\n  }\n\n  /**\n  * Project a screen point to tile point\n  * @param {IPoint3} point - The screen coordinates to project\n  * @param {IRectangle3=} dimensions - The dimensions of each tile on the map, defaults to `this.baseTileDimensions`\n  * @param {IPoint=} origin - The origin point of the tile\n  * @return {IPoint3} The tile coordinate in the map\n  *\n  * @example\n  *\n  *    const tilePosition = tileMap.toTile({ x: 400, y: 300 })\n  */\n  public toTile(point: IPoint3, dimensions = this.baseTileDimensions, origin = this.baseTileOrigin): IPoint3 {\n    const p = this._unproject(point)\n    return {\n      x: Math.round(p.x / dimensions.width),\n      y: Math.round(p.y / dimensions.height),\n      z: point.z || 0\n    }\n  }\n\n  /**\n  * Returns the new position of the tiles' parent container where the given tile is in the center of the viewport.\n  * @param {IPoint3} point - The map coordinates to center\n  * @return {IPoint}\n  *\n  * @example\n  *\n  *    const worldPosition = tilemap.centerToTile({ x: 1, y: 1, z: 0 })\n  */\n  public centerToTile(point: IPoint3): IPoint {\n    return this.centerToPoint(this.toPoint(point))\n  }\n\n  /**\n  * Returns the new position of the tiles' parent container where the given screen point is in the center of the viewport.\n  * @param {IPoint3} point - The screen coordinates to center\n  * @return {IPoint}\n  *\n  * @example\n  *\n  *    const worldPosition = tilemap.centerToPoint({ x: 500, y: 200 })\n  */\n  public centerToPoint(point: IPoint): IPoint {\n    const globalDimensions = this.getGlobalDimensions()\n    const worldPosition = this.getWorldPosition()\n    return {\n      x: worldPosition.x + (globalDimensions.width / 2) - point.x,\n      y: worldPosition.y + (globalDimensions.height / 2) - point.y\n    }\n  }\n\n  /**\n  * Calculates the current map bounds and returns the tile coordinates in the center\n  * @return {IPoint}\n  *\n  * @example\n  *\n  *    const { x, y } = tilemap.centerTile\n  */\n  public get centerTile(): IPoint {\n    return this.getBounds()\n  }\n\n  /**\n  * Calls `tilemap.centerToTile(this.centerTile)` and returns the new position of the tiles' parent container where the center tile is in the center of the viewport.\n  * @return {IPoint}\n  *\n  * @example\n  *\n  *    const { x, y } = tilemap.center()\n  */\n  public center(): IPoint {\n    return this.centerToTile(this.centerTile)\n  }\n\n  /**\n  * Calculates the map bounds of the current tilemap.\n  * @return {IBox}\n  *\n  * @example\n  *\n  *    const { x, y, width, height, depth } = tilemap.getBounds()\n  */\n  public getBounds(): IBox {\n    const grids = Object.values(this.map)\n    const xes = grids.map(o => Object.keys(o).map(Number)).flat()\n    const yes = grids.map(Object.values).flat().map(o => Object.keys(o).map(Number)).flat()\n\n    const minX = Math.min(...xes), maxX = Math.max(...xes), minY = Math.min(...yes), maxY = Math.max(...yes)\n\n    const rect = {\n      x: 0,\n      y: 0,\n      width: maxX - minY,\n      height: maxY - minY,\n      depth: grids.length\n    }\n\n    rect.x = Math.round(minX + (rect.width / 2))\n    rect.y = Math.round(minY + (rect.height / 2))\n\n    return rect\n  }\n\n  protected _project(point3: IPoint3, dimensions = this.baseTileDimensions, origin = this.baseTileOrigin): IPoint3 {\n    const { width, height } = this.getGlobalDimensions();\n    return {\n      x: point3.x + (width * this.worldOrigin.x),\n      y: point3.y + (height * this.worldOrigin.y),\n      z: point3.z || 0\n    };\n  }\n\n  protected _unproject(point: IPoint3, out: IPoint3 = { x: 0, y: 0, z: 0 }) {\n    const { width, height } = this.getGlobalDimensions()\n    out.x = point.x - (width * this.worldOrigin.x);\n    out.y = point.y - (height * this.worldOrigin.y) + (point.z || 0);\n    out.z = point.z\n    return out;\n  }\n\n  protected _getAbsolutePosition(point: IPoint3, dimensions = this.baseTileDimensions, origin = this.baseTileOrigin): IPoint3 {\n    return {\n      x: this.baseTileDimensions.width * point.x,\n      y: this.baseTileDimensions.height * point.y,\n      z: point.z\n    }\n  }\n}","import { IPoint3, IPoint, IRectangle3 } from './interfaces'\nimport { set, sum, CLASSIC } from './utils'\nimport { Tilemap, ITilemapConfig } from './Tilemap'\n\n/**\n * Object extending `ITilemapConfig` with optional projectionAngle, defaulting to `CLASSIC`\n */\nexport interface IIsoTilemapConfig extends ITilemapConfig {\n  /** Isometric projection angle, defaults to `CLASSIC` */\n  angle?: number\n  /**\n   * It's a good idea to clamp your values to aid performance. In general having values aligned around the 0.5 value will produce a well performing and visually appealing display.\n   */\n  clamp?: boolean\n}\n\n/**\n * Class that extends basic 2D Tilemap functionality based on given projectionAngle.\n * @param {T} - The type of sprite object to store\n * @extends Tilemap\n */\nexport class IsoTilemap<T> extends Tilemap<T> {\n\n  protected readonly angle: number;\n  protected readonly angleCos: number;\n  protected readonly angleSin: number\n  protected readonly clamp: boolean\n\n  protected readonly baseOrigin: IPoint\n  protected readonly baseSurfaceHeight: number\n  protected readonly baseSurfaceHalfHeight: number\n  readonly depthMap: { [z: number]: { [x: number]: { [y: number]: number } } } = {}\n\n  /**\n  * Create an `IsoTilemap<T>` instance.\n  * @param {IIsoTilemapConfig} config - projectionAngle will default to CLASSIC\n  */\n  constructor({ angle = CLASSIC, clamp = true, ...config }: IIsoTilemapConfig) {\n    super({ ...config })\n    this.angle = angle;\n    this.angleCos = Math.cos(this.angle);\n    this.angleSin = Math.sin(this.angle);\n    this.clamp = clamp\n    this.baseOrigin = { x: this.baseTileDimensions.width * this.baseTileOrigin.x, y: this.baseTileDimensions.height * this.baseTileOrigin.y }\n    this.baseSurfaceHeight = (this.baseTileDimensions.height - this.baseTileDimensions.depth)\n    this.baseSurfaceHalfHeight = this.baseSurfaceHeight / 2\n  }\n\n  /**\n  * Add tile to the tilemap at given coordinate.\n  * If given tile is tall enough to occupy multiple z-layers at the base tile depth, it will add a reference at those z-layers in the map.\n  * @param {T} tile\n  * @param {IPoint3} point - The map coordinates at which to store this tile\n  * @param {IRectangle3=} dimensions - The dimensions of the tile, defaults to `this.baseTileDimensions`\n  * @param {IPoint=} origin - The origin point of the tile, defaults to `this.baseTileOrigin`\n  * @return {IPoint3} A 3D Point at which to place this tile in screen space\n  *\n  * @example\n  *\n  *    const position = isoTilemap.add({}, { x: 1, y: 1, z: 0 })\n  */\n  public add(sprite: T, point: IPoint3, dimensions: IRectangle3 = this.baseTileDimensions, origin = this.baseTileOrigin): IPoint3 {\n    this.tiles.push(sprite)\n    const tile = this.tiles[this.tiles.indexOf(sprite)]\n    if (dimensions !== this.baseTileDimensions) {\n      let d = dimensions.depth / this.baseTileDimensions.depth\n      for (let i = d, z = point.z; i > 0; i--, z++) {\n        if (i > 1) {\n          set(this.depthMap, [z, point.x, point.y], this.baseTileDimensions.depth)\n        } else {\n          set(this.depthMap, [z, point.x, point.y], this.baseTileDimensions.depth * i)\n        }\n        set(this.map, [z, point.x, point.y], tile)\n      }\n    } else {\n      set(this.depthMap, [point.z, point.x, point.y], this.baseTileDimensions.depth)\n      set(this.map, [point.z, point.x, point.y], tile)\n    }\n    return this._project(\n      this._getAbsolutePosition(point),\n      dimensions,\n      origin,\n      sum(this.getColumn<number>(point, this.depthMap).slice(1, point.z))\n    )\n  }\n\n  /**\n  * Remove a tile from the given point coordinates.\n  * If the tile exists at multiple z-layers, it'll remove references to the tile at those layers as well.\n  * @param {IPoint3} point - The map coordinates from which to remove a tile\n  * @return {[T]} The tile that existed at the given point, or null if there was no tile.\n  *\n  * @example\n  *\n  *    const removedTile = isoTilemap.remove({ x: 1, y: 1, z: 0 })\n  */\n  public remove(point: IPoint3): T {\n    const tile = this.get(point)\n    if (!tile) return null\n    Object.entries(this.map).forEach(([z, grid]) => {\n      try {\n        if (grid[point.x][point.y] === tile) {\n          delete this.depthMap[z][point.x][point.y]\n          delete this.map[z][point.x][point.y]\n        }\n      } catch { }\n    })\n    return this.tiles.splice(this.tiles.indexOf(tile), 1)[0]\n  }\n\n  /**\n  * Project a screen point to tile point\n  * @param {IPoint3} point - The screen coordinates to project\n  * @param {IRectangle3=} dimensions - The dimensions of each tile on the map, defaults to `this.baseTileDimensions`\n  * @param {IPoint=} origin - The origin point of the tile\n  * @return {IPoint3} The tile coordinate in the map\n  *\n  * @example\n  *\n  *    const tilePosition = isoTilemap.toTile({ x: 400, y: 300 })\n  */\n  public toTile(point: IPoint3, dimensions = this.baseTileDimensions, origin = this.baseTileOrigin): IPoint3 {\n    const p = this._unproject(point)\n    const edge = { x: dimensions.width * origin.x, y: dimensions.width * origin.y }\n    p.x = Math.floor((p.x + edge.x) / edge.x)\n    p.y = Math.floor((p.y + edge.y) / edge.y)\n    p.z = p.z || 0\n    return p\n  }\n\n  protected _project(p: IPoint3, dimensions = this.baseTileDimensions, origin = this.baseTileOrigin, depth: number = 0): IPoint3 {\n    // calculate the cartesion coordinates\n    const { width, height } = this.getGlobalDimensions()\n    const out = {\n      x: ((p.x - p.y) * this.angleCos) + (width * this.worldOrigin.x),\n      y: ((p.x + p.y) * this.angleSin) + (height * this.worldOrigin.y),\n      z: (p.x + p.y) * (p.z + 1 || 1)\n    }\n    if (dimensions !== this.baseTileDimensions) {\n      out.y -= (this.baseSurfaceHalfHeight + 0) - this.baseTileOrigin.y // + (this.baseTileDimensions.depth * point3.z)) - this.baseTileOrigin.y\n      out.y += (dimensions.height * origin.y) - (dimensions.height - ((dimensions.height - dimensions.depth) / 2))\n      out.y -= depth\n    } else {\n      out.y -= (this.baseTileDimensions.depth * p.z)\n    }\n    // if we are clamping, then clamp the values\n    // clamp using the fastest proper rounding: http://jsperf.com/math-round-vs-hack/3\n    if (this.clamp) {\n      out.x = ~~(out.x + (out.x > 0 ? 0.5 : -0.5))\n      out.y = ~~(out.y + (out.y > 0 ? 0.5 : -0.5))\n    }\n    return out\n  }\n\n  protected _unproject(point: IPoint3, out: IPoint3 = { x: 0, y: 0, z: 0 }) {\n    const worldDimensions = this.getGlobalDimensions()\n    const x = point.x - (worldDimensions.width * this.worldOrigin.x);\n    const y = point.y - (worldDimensions.height * this.worldOrigin.y);\n\n    out.x = x / (2 * this.angleCos) + y / (2 * this.angleSin);\n    out.y = -(x / (2 * this.angleCos)) + y / (2 * this.angleSin);\n    out.z = point.z || 0;\n\n    return out;\n  }\n\n  protected _getAbsolutePosition(point: IPoint3, dimensions = this.baseTileDimensions, origin = this.baseTileOrigin): IPoint3 {\n    return {\n      x: (dimensions.width * origin.x) * point.x,\n      y: (dimensions.width * origin.y) * point.y,\n      z: point.z || 0\n    }\n  }\n}"],"names":["CLASSIC","DIRECTION","Math","atan","ISOMETRIC","PI","MILITARY","TOP_LEFT","x","y","MIDDLE","FULL","set","obj","indices","value","o","length","n","shift","get","setIfNull","getDistance","from","to","sqrt","sum","numbers","reduce","s","getDirection","diffX","diffY","N","NE","E","SE","S","SW","W","NW","NONE","Tilemap","worldOrigin","baseTileOrigin","baseTileDimensions","getGlobalDimensions","getWorldPosition","getWorldScale","tiles","map","this","add","sprite","point","dimensions","origin","push","tile","indexOf","z","_project","_getAbsolutePosition","getColumn","Object","entries","move","remove","splice","toPoint","scale","worldPosition","p","toTile","_unproject","round","width","height","centerToTile","centerToPoint","globalDimensions","center","centerTile","getBounds","grids","values","xes","keys","Number","flat","yes","minX","min","maxX","max","minY","rect","depth","point3","out","IsoTilemap","angle","clamp","config","_this","angleCos","angleSin","baseOrigin","baseSurfaceHeight","baseSurfaceHalfHeight","depthMap","cos","sin","i","slice","forEach","grid","_this2","edge","floor","worldDimensions"],"mappings":"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"}